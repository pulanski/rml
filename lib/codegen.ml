open Ir

let counter = ref 0

let fresh_var () =
  let var = Printf.sprintf "%%%d" !counter in
  incr counter;
  var

let reset_counter () =
  counter := 0

let rec emit_mlir_expr = function
  | IRNumber n -> Printf.sprintf "%f" n
  | IRVariable x -> x
  | IRCall (func_name, args) ->
      let args_str = String.concat ", " (List.map emit_mlir_expr args) in
      Printf.sprintf "%s(%s)" func_name args_str
  | IRBinOp (op, lhs, rhs) ->
      Printf.sprintf "%s %s, %s : f64" (emit_op op) (emit_mlir_expr lhs) (emit_mlir_expr rhs)
  (* | IRTensor elements ->
      let elements_str = String.concat ", " (List.map emit_mlir_expr elements) in
      (* get dims *)
      Printf.sprintf "rml.constant dense<[%s]> : tensor<ixjxf64>" elements_str *)
  | IRTensor (shape, elements) ->
    let shape_str = String.concat "x" (List.map string_of_int shape) in
    let elements_str = String.concat ", " (List.map emit_mlir_expr elements) in
    Printf.sprintf "rml.constant dense<[%s]> : tensor<%sxf64>" elements_str shape_str

and emit_op = function
  | IRAdd -> "rml.add"
  | IRSub -> "rml.sub"
  | IRMul -> "rml.mul"
  | IRDiv -> "rml.div"

let emit_mlir_stmt = function
  | IRExpr expr -> emit_mlir_expr expr
  | IRReturn expr -> "return " ^ emit_mlir_expr expr
  | IRVarDecl (_name, expr) ->
      let var_name = fresh_var () in
      Printf.sprintf "%s = %s" var_name (emit_mlir_expr expr)

let emit_mlir_function func =
  reset_counter ();
  let stmts_str = String.concat "\n  " (List.map emit_mlir_stmt func.body) in
  let params_str = String.concat ", " func.params in
  Printf.sprintf "rml.func @%s(%s) {\n  %s\n}\n" func.name params_str stmts_str

let emit_mlir ir_program =
  let header = "// MLIR module generated by rml compiler\n" in
  let functions_str = String.concat "\n" (List.map emit_mlir_function ir_program) in
  header ^ "module {\n" ^ functions_str ^ "}\n"
