open Ir

let counter = ref 0

let fresh_var () =
  let var = Printf.sprintf "%%%d" !counter in
  incr counter;
  var

let reset_counter () =
  counter := 0

let rec emit_mlir_expr = function
  | IRNumber n -> Printf.sprintf "arith.constant %f : f64" n
  | IRVariable x -> x
  | IRCall (func_name, args) ->
      let args_str = String.concat ", " (List.map emit_mlir_expr args) in
      Printf.sprintf "%s(%s)" func_name args_str
  | IRBinOp (op, lhs, rhs) ->
      Printf.sprintf "%s %s, %s : f64" (emit_op op) (emit_mlir_expr lhs) (emit_mlir_expr rhs)
  | IRTensor elements ->
      let elements_str = String.concat ", " (List.map emit_mlir_expr elements) in
      Printf.sprintf "tensor_literal(%s)" elements_str

and emit_op = function
  | IRAdd -> "arith.addf"
  | IRSub -> "arith.subf"
  | IRMul -> "arith.mulf"
  | IRDiv -> "arith.divf"

let emit_mlir_stmt = function
  | IRExpr expr -> emit_mlir_expr expr
  | IRReturn expr -> "return " ^ emit_mlir_expr expr
  | IRVarDecl (_name, expr) ->
      let var_name = fresh_var () in
      Printf.sprintf "%s = %s" var_name (emit_mlir_expr expr)

let emit_mlir_function func =
  reset_counter ();
  let stmts_str = String.concat "\n  " (List.map emit_mlir_stmt func.body) in
  let params_str = String.concat ", " func.params in
  Printf.sprintf "toy.func @%s(%s) {\n  %s\n}\n" func.name params_str stmts_str

let emit_mlir ir_program =
  let header = "// MLIR module generated by Toy compiler\n" in
  let functions_str = String.concat "\n" (List.map emit_mlir_function ir_program) in
  header ^ "module {\n" ^ functions_str ^ "}\n"
